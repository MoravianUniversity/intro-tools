/**
 * TypeEditor - A visual editor for Python type annotations
 * 
 * Creates an interactive editor for building and editing Python type annotations
 * with support for base types (int, float, str, bool) and container types 
 * (list, tuple, set, dict).
 * 
 * This was mostly generated by AI, with guidance and tweaks by Jeffrey Bush.
 * 
 * @example
 * // Basic usage
 * const editor = new TypeEditor(document.getElementById('editor'));
 * 
 * @example
 * // With change callback
 * const editor = new TypeEditor(document.getElementById('editor'), {
 *     onChange: (typeString) => {
 *         console.log('Type changed:', typeString);
 *         document.getElementById('output').textContent = typeString;
 *     }
 * });
 * 
 * @example
 * // With initial type
 * const editor = new TypeEditor(document.getElementById('editor'), {
 *     initialType: 'list of tuple with int and str'
 * });
 * 
 * @example
 * // With custom allowed types
 * const editor = new TypeEditor(document.getElementById('editor'), {
 *     allowedTypes: ['int', 'str', 'list', 'dict']
 * });
 * 
 * @example
 * // Getting the current type
 * const currentType = editor.getTypeString();
 * console.log(currentType); // e.g., "list of tuple with int and str"
 * 
 * @example
 * // Setting from a string
 * try {
 *     editor.setTypeString('dict with keys of str associated with values of int');
 * } catch (error) {
 *     console.error('Parse error:', error.message);
 * }
 * 
 * @example
 * // Resetting the editor
 * editor.clear();
 */
class TypeEditor {
    /**
     * Creates a new TypeEditor instance
     * 
     * @param {HTMLElement} element - The DOM element where the editor will be mounted.
     *                                 The class 'type-editor' will be added to this element.
     * @param {Object} [options={}] - Configuration options
     * @param {function(string):void} [options.onChange] - Callback function that will be called 
     *                                                      whenever the type changes. Receives the 
     *                                                      new type string as a parameter.
     * @param {string[]} [options.allowedTypes] - Array of allowed type names. If not provided,
     *                                             defaults to ['int', 'float', 'str', 'bool', 
     *                                             'list', 'tuple', 'set', 'dict'].
     * @param {string} [options.initialType] - Initial type string to parse and display. If not 
     *                                          provided, defaults to the first available type.
     * 
     * @example
     * // Simple initialization
     * const editor = new TypeEditor(document.getElementById('my-editor'));
     * 
     * @example
     * // With callback
     * const editor = new TypeEditor(document.getElementById('my-editor'), {
     *     onChange: (typeString) => {
     *         console.log('New type:', typeString);
     *     }
     * });
     * 
     * @example
     * // With custom allowed types
     * const editor = new TypeEditor(document.getElementById('my-editor'), {
     *     allowedTypes: ['int', 'str', 'list', 'dict']
     * });
     * 
     * @example
     * // With initial type
     * const editor = new TypeEditor(document.getElementById('my-editor'), {
     *     initialType: 'list of tuple with int and str'
     * });
     * 
     * @example
     * // With all options
     * const editor = new TypeEditor(document.getElementById('my-editor'), {
     *     onChange: (typeString) => console.log(typeString),
     *     allowedTypes: ['int', 'str', 'list'],
     *     initialType: 'list of int'
     * });
     */
    // Private fields
    #element;
    #typeId;
    #onChangeCallback;
    #baseTypes;
    #containerTypes;
    #allTypes;

    constructor(element, options = {}) {
        this.#element = element;
        this.#element.classList.add('type-editor');
        this.#typeId = 0;
        this.#onChangeCallback = options.onChange || null;
        
        // Default types
        const defaultBaseTypes = ['int', 'float', 'str', 'bool'];
        const defaultContainerTypes = ['list', 'tuple', 'set', 'dict'];
        const defaultAllTypes = [...defaultBaseTypes, ...defaultContainerTypes];
        
        if (options.allowedTypes) {
            this.#allTypes = [...options.allowedTypes];
            this.#baseTypes = options.allowedTypes.filter(t => defaultBaseTypes.includes(t));
            this.#containerTypes = options.allowedTypes.filter(t => defaultContainerTypes.includes(t));
        } else {
            this.#baseTypes = defaultBaseTypes;
            this.#containerTypes = defaultContainerTypes;
            this.#allTypes = defaultAllTypes;
        }
        
        // Initialize with initial type or default
        if (options.initialType) {
            try {
                this.setTypeString(options.initialType);
            } catch (error) {
                // If initial type fails to parse, fall back to default
                console.warn('Failed to parse initialType:', error.message);
                this.clear();
            }
        } else {
            this.clear();
        }
    }
    
    /**
     * Gets the current type as an English string
     * 
     * Returns a human-readable string representation of the currently
     * constructed type. The string uses natural language syntax like
     * "list of int" or "tuple with int, str, and float".
     * 
     * @returns {string} The current type as a string, or empty string if no type is set
     * 
     * @example
     * const typeString = editor.getTypeString();
     * console.log(typeString); // "list of int"
     * 
     * @example
     * // Complex nested type
     * const typeString = editor.getTypeString();
     * console.log(typeString); // "dict with keys of str associated with values of (list of int)"
     */
    getTypeString() {
        const rootContainer = this.#element.querySelector('.type-container');
        if (rootContainer) {
            return this.#generateTypeString(rootContainer);
        }
        return '';
    }
    
    /**
     * Parses and sets the editor from a type string
     * 
     * Parses an English type string and rebuilds the editor to match.
     * Supports multiple syntax variations for convenience, including
     * bare container type names.
     * 
     * @param {string} typeStr - The type string to parse. Must be a valid type expression
     *                           in English format (e.g., "list of int", "tuple with int and str")
     * 
     * @throws {Error} If the type string cannot be parsed
     * 
     * @example
     * // Simple type
     * editor.setTypeString('list of int');
     * 
     * @example
     * // Bare container types (uses default nested type)
     * editor.setTypeString('list');   // becomes "list of int"
     * editor.setTypeString('tuple');  // becomes "tuple with int"
     * editor.setTypeString('set');    // becomes "set of int"
     * editor.setTypeString('dict');   // becomes "dict with keys of int associated with values of int"
     * 
     * @example
     * // Nested container types
     * editor.setTypeString('list of tuple with int, str, and float');
     * 
     * @example
     * // Dict with various syntaxes
     * editor.setTypeString('dict with keys of str associated with values of int');
     * editor.setTypeString('dict with keys of int and values of str');
     * editor.setTypeString('dict of int to str');
     * editor.setTypeString('dict of list of int');  // assumes str keys
     * 
     * @example
     * // With error handling
     * try {
     *     editor.setTypeString('invalid type string');
     * } catch (error) {
     *     console.error('Failed to parse:', error.message);
     * }
     * 
     * @example
     * // Complex nested types with parentheses
     * editor.setTypeString('tuple with (list of int), str, and (set of float)');
     */
    setTypeString(typeStr) {
        try {
            const parsed = this.#parseTypeString(typeStr);
            this.#element.innerHTML = '';
            this.#typeId = 0;
            this.#buildTypeFromParsed(parsed, this.#element);
            this.#notifyChange();
        } catch (error) {
            throw new Error('Error parsing type string: ' + error.message);
        }
    }
    
    /**
     * Clears the editor and resets to initial state
     * 
     * Removes all type selections and resets the editor to show
     * a single type dropdown. Triggers the onChange callback if set.
     * 
     * @example
     * editor.clear();
     * 
     * @example
     * // Clear and get the default type
     * editor.clear();
     * console.log(editor.getTypeString()); // "int" (default first type)
     */
    clear() {
        this.#element.innerHTML = '';
        this.#typeId = 0;
        this.#createTypeDropdown(this.#element, true);
    }
    
    // Private: Notify of changes
    #notifyChange() {
        if (this.#onChangeCallback) {
            this.#onChangeCallback(this.getTypeString());
        }
    }

    // Private: Check if we need immutable types only (inside set or dict keys)
    #needsImmutableTypes(element) {
        let current = element;
        while (current) {
            if (current.classList && current.classList.contains('type-container')) {
                const select = current.querySelector(':scope > select');
                if (select && select.value === 'set') {
                    return true;
                }
                if (select && select.value === 'dict') {
                    // Check if we're in the keys section of a dict
                    let checkElement = element;
                    while (checkElement && checkElement !== current) {
                        if (checkElement.classList && checkElement.classList.contains('indented-nested')) {
                            const label = checkElement.querySelector('.dict-label');
                            if (label && label.textContent === 'keys of') {
                                return true;
                            }
                        }
                        checkElement = checkElement.parentElement;
                    }
                }
                // Also check if inside a tuple that's inside a restricted context
                if (select && select.value === 'tuple') {
                    current = current.parentElement;
                    continue;
                }
            }
            current = current.parentElement;
        }
        return false;
    }

    // Private: Backward compatibility wrapper
    #isInsideSet(element) {
        return this.#needsImmutableTypes(element);
    }

    #createTypeDropdown(parent, isRoot = false) {
        const container = document.createElement('span');
        container.className = 'type-container';
        const id = this.#typeId++;
        container.dataset.id = id;

        const select = document.createElement('select');

        // Determine which types to show based on context
        const inSetContext = this.#isInsideSet(parent);
        const immutableTypes = [...this.#baseTypes, 'tuple'];
        const typesToShow = inSetContext ? immutableTypes : this.#allTypes;

        // Add type options
        typesToShow.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            select.appendChild(option);
        });

        // Default to first option
        select.selectedIndex = 0;

        select.addEventListener('change', (e) => this.#handleTypeChange(e, container, id));
        
        container.appendChild(select);
        parent.appendChild(container);
        
        // Trigger initial change to set up nested elements if needed
        this.#handleTypeChange({ target: select }, container, id);
        
        return container;
    }

    #handleTypeChange(event, container, id) {
        const selectedType = event.target.value;
        
        // Remove any existing nested elements
        const childElements = container.querySelectorAll('.type-container:not(:first-child), .mode-select, .connector, .add-type-btn, .remove-type-btn, .indented-nested, .dict-label, .dict-connector');
        childElements.forEach(el => el.remove());

        if (this.#containerTypes.includes(selectedType)) {
            if (selectedType === 'list') {
                this.#addContainerInterface(container, 'of'); // List defaults to 'of'
            } else if (selectedType === 'set') {
                this.#addSetInterface(container);
            } else if (selectedType === 'tuple') {
                this.#addContainerInterface(container, 'with'); // Tuple defaults to 'with'
            } else if (selectedType === 'dict') {
                this.#addDictInterface(container);
            }
        }
        
        this.#notifyChange();
    }

    #addSetInterface(container) {
        // Set only supports 'of' mode, show 'of' label
        const connector = document.createElement('span');
        connector.className = 'connector';
        connector.textContent = 'of';
        container.appendChild(connector);
        
        // Wrap nested type in indented container
        const nestedWrapper = document.createElement('div');
        nestedWrapper.className = 'indented-nested';
        container.appendChild(nestedWrapper);
        
        this.#createTypeDropdown(nestedWrapper);
    }

    #addDictInterface(container) {
        // Dict always uses 'with'
        const connector = document.createElement('span');
        connector.className = 'connector';
        connector.textContent = 'with';
        container.appendChild(connector);
        
        // Keys section
        const keysWrapper = document.createElement('div');
        keysWrapper.className = 'indented-nested';
        container.appendChild(keysWrapper);
        
        const keysLabel = document.createElement('span');
        keysLabel.className = 'dict-label';
        keysLabel.textContent = 'keys of';
        keysWrapper.appendChild(keysLabel);
        
        this.#createTypeDropdown(keysWrapper);
        
        // "associated with" on its own line
        const associatedWith = document.createElement('div');
        associatedWith.className = 'dict-connector';
        associatedWith.textContent = 'associated with';
        container.appendChild(associatedWith);
        
        // Values section
        const valuesWrapper = document.createElement('div');
        valuesWrapper.className = 'indented-nested';
        container.appendChild(valuesWrapper);
        
        const valuesLabel = document.createElement('span');
        valuesLabel.className = 'dict-label';
        valuesLabel.textContent = 'values of';
        valuesWrapper.appendChild(valuesLabel);
        
        this.#createTypeDropdown(valuesWrapper);
    }

    #addContainerInterface(container, defaultMode) {
        // Create dropdown for "of" vs "with"
        const modeSelect = document.createElement('select');
        modeSelect.className = 'mode-select';

        const ofOption = document.createElement('option');
        ofOption.value = 'of';
        ofOption.textContent = 'of';
        ofOption.title = 'Contains an arbitrary number of elements, all of the same type';
        modeSelect.appendChild(ofOption);

        const withOption = document.createElement('option');
        withOption.value = 'with';
        withOption.textContent = 'with';
        withOption.title = 'Contains a fixed number of elements, each of a possiblydifferent type';
        modeSelect.appendChild(withOption);

        // Set default
        modeSelect.value = defaultMode;

        container.appendChild(modeSelect);

        // Add change listener
        modeSelect.addEventListener('change', (e) => this.#updateContainerMode(container, e.target.value));

        // Initialize with default mode
        this.#updateContainerMode(container, defaultMode);
    }

    #updateContainerMode(container, mode) {
        // Remove existing type dropdowns, buttons, and nested wrappers after mode selection
        const existingTypes = container.querySelectorAll('.type-container:not(:first-child)');
        const existingButtons = container.querySelectorAll('.add-type-btn, .remove-type-btn');
        const existingWrappers = container.querySelectorAll('.indented-nested');
        existingTypes.forEach(el => el.remove());
        existingButtons.forEach(el => el.remove());
        existingWrappers.forEach(el => el.remove());

        if (mode === 'of') {
            // Single type dropdown in indented wrapper
            const nestedWrapper = document.createElement('div');
            nestedWrapper.className = 'indented-nested';
            container.appendChild(nestedWrapper);
            
            this.#createTypeDropdown(nestedWrapper);
        } else {
            // Multiple type dropdowns with add/remove buttons, all at same indent
            this.#addWithType(container, true);
        }
        
        this.#notifyChange();
    }

    #addWithType(container, isFirst = false) {
        // Create indented wrapper for each type in "with" mode
        const itemWrapper = document.createElement('div');
        itemWrapper.className = 'indented-nested';
        container.appendChild(itemWrapper);
        
        // Add buttons at the front of the line
        const buttonContainer = document.createElement('span');
        buttonContainer.className = 'nested-leader-container';
        itemWrapper.appendChild(buttonContainer);

        // Add "+" button
        const addBtn = document.createElement('button');
        addBtn.className = 'add-type-btn';
        addBtn.textContent = '+';
        addBtn.addEventListener('click', () => {
            this.#addWithType(container, false);
            this.#updateWithButtonStates(container);
        });
        buttonContainer.appendChild(addBtn);

        // Add remove button (always present)
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-type-btn';
        removeBtn.textContent = '−';
        removeBtn.addEventListener('click', () => {
            // Remove the entire wrapper
            itemWrapper.remove();
            this.#updateWithButtonStates(container);
            this.#notifyChange();
        });
        buttonContainer.appendChild(removeBtn);

        // Add the type dropdown after buttons
        const typeContainer = this.#createTypeDropdown(itemWrapper);

        // Update button states after adding
        this.#updateWithButtonStates(container);

        return typeContainer;
    }

    #updateWithButtonStates(container) {
        // Count how many "with" items exist
        const nestedWrappers = Array.from(container.children).filter(child => 
            child.classList && child.classList.contains('indented-nested')
        );
        
        // Enable/disable remove buttons based on count
        nestedWrappers.forEach(wrapper => {
            const removeBtn = wrapper.querySelector('.remove-type-btn');
            if (removeBtn) {
                removeBtn.disabled = nestedWrappers.length <= 1;
            }
        });
    }

    #needsParentheses(typeString) {
        // Check if the type string contains mode keywords that need disambiguation
        return typeString.includes(' of ') || typeString.includes(' with ');
    }

    #formatWithList(types) {
        // Format a list of types with commas and trailing "and"
        if (types.length === 0) return '';
        if (types.length === 1) return types[0];
        if (types.length === 2) return `${types[0]} and ${types[1]}`;
        // For 3 or more, use commas with trailing "and"
        const allButLast = types.slice(0, -1).join(', ');
        return `${allButLast}, and ${types[types.length - 1]}`;
    }

    #generateTypeString(container) {
        const select = container.querySelector('select');
        const selectedType = select.value;
        
        if (!selectedType) {
            return '?';
        }

        if (this.#baseTypes.includes(selectedType)) {
            return selectedType;
        }

        if (selectedType === 'set') {
            // Set only supports 'of' mode
            const nestedWrapper = container.querySelector('.indented-nested');
            if (nestedWrapper) {
                const nestedContainer = nestedWrapper.querySelector('.type-container');
                if (nestedContainer) {
                    const nestedType = this.#generateTypeString(nestedContainer);
                    const wrappedType = this.#needsParentheses(nestedType) ? `(${nestedType})` : nestedType;
                    return `set of ${wrappedType}`;
                }
            }
            return 'set of ?';
        }

        if (selectedType === 'dict') {
            // Dict has two sections: keys and values
            const nestedWrappers = Array.from(container.children).filter(child => 
                child.classList && child.classList.contains('indented-nested')
            );
            
            let keyType = '?';
            let valueType = '?';
            
            nestedWrappers.forEach(wrapper => {
                const label = wrapper.querySelector('.dict-label');
                const typeContainer = wrapper.querySelector('.type-container');
                
                if (label && typeContainer) {
                    const typeString = this.#generateTypeString(typeContainer);
                    if (label.textContent === 'keys of') {
                        keyType = typeString;
                    } else if (label.textContent === 'values of') {
                        valueType = typeString;
                    }
                }
            });
            
            const wrappedKeyType = this.#needsParentheses(keyType) ? `(${keyType})` : keyType;
            const wrappedValueType = this.#needsParentheses(valueType) ? `(${valueType})` : valueType;
            
            return `dict with keys of ${wrappedKeyType} associated with values of ${wrappedValueType}`;
        }

        if (selectedType === 'list' || selectedType === 'tuple') {
            const modeSelect = container.querySelector('.mode-select');
            const mode = modeSelect ? modeSelect.value : 'of';

            if (mode === 'of') {
                const nestedWrapper = container.querySelector('.indented-nested');
                if (nestedWrapper) {
                    const nestedContainer = nestedWrapper.querySelector('.type-container');
                    if (nestedContainer) {
                        const nestedType = this.#generateTypeString(nestedContainer);
                        const wrappedType = this.#needsParentheses(nestedType) ? `(${nestedType})` : nestedType;
                        return `${selectedType} of ${wrappedType}`;
                    }
                }
                return `${selectedType} of ?`;
            } else {
                // "with" mode - collect types from indented wrappers
                const nestedWrappers = Array.from(container.children).filter(child => 
                    child.classList && child.classList.contains('indented-nested')
                );
                
                if (nestedWrappers.length > 0) {
                    const types = nestedWrappers.map(wrapper => {
                        const typeContainer = wrapper.querySelector('.type-container');
                        if (!typeContainer) return '?';
                        const typeString = this.#generateTypeString(typeContainer);
                        // Add parentheses to child types in "with" if they contain mode keywords
                        return this.#needsParentheses(typeString) ? `(${typeString})` : typeString;
                    });
                    return `${selectedType} with ${this.#formatWithList(types)}`;
                }
                return `${selectedType} with ?`;
            }
        }

        return selectedType;
    }

    // Private: Parser functions
    #parseTypeString(typeStr) {
        typeStr = typeStr.trim();
        
        // Check for base types
        if (this.#baseTypes.includes(typeStr)) {
            return { type: typeStr };
        }
        
        // Check for bare container types (e.g., just "list", "tuple", "set", "dict")
        if (this.#containerTypes.includes(typeStr)) {
            const defaultBaseType = this.#baseTypes.length > 0 ? this.#baseTypes[0] : 'int';
            
            if (typeStr === 'list') {
                return {
                    type: 'list',
                    mode: 'of',
                    nested: { type: defaultBaseType }
                };
            } else if (typeStr === 'tuple') {
                return {
                    type: 'tuple',
                    mode: 'with',
                    types: [{ type: defaultBaseType }]
                };
            } else if (typeStr === 'set') {
                return {
                    type: 'set',
                    mode: 'of',
                    nested: { type: defaultBaseType }
                };
            } else if (typeStr === 'dict') {
                return {
                    type: 'dict',
                    keyType: { type: defaultBaseType },
                    valueType: { type: defaultBaseType }
                };
            }
        }
        
        // Parse container types with modifiers
        for (const containerType of this.#containerTypes) {
            if (typeStr.startsWith(containerType + ' ')) {
                const rest = typeStr.substring(containerType.length + 1).trim();
                
                if (containerType === 'set') {
                    // Set only supports "of"
                    if (rest.startsWith('of ')) {
                        const nested = rest.substring(3).trim();
                        return {
                            type: 'set',
                            mode: 'of',
                            nested: this.#parseTypeString(this.#stripParentheses(nested))
                        };
                    }
                } else if (containerType === 'dict') {
                    // Dict has multiple syntax options
                    if (rest.startsWith('with ')) {
                        const dictContent = rest.substring(5).trim();
                        
                        // Check for "with values of X" (str keys assumed)
                        if (dictContent.startsWith('values of ')) {
                            const valueTypeStr = dictContent.substring(10).trim();
                            return {
                                type: 'dict',
                                keyType: { type: 'str' },
                                valueType: this.#parseTypeString(this.#stripParentheses(valueTypeStr))
                            };
                        }
                        
                        // Parse "with keys of X ..."
                        if (dictContent.startsWith('keys of ')) {
                            const afterKeysOf = dictContent.substring(8);
                            // Find separator: "associated with values of" or "and values of"
                            let depth = 0;
                            let splitIndex = -1;
                            let searchPhrase = null;
                            
                            // Try both separators
                            const separators = ['associated with values of ', 'and values of '];
                            
                            for (const sep of separators) {
                                depth = 0;
                                for (let i = 0; i < afterKeysOf.length; i++) {
                                    const char = afterKeysOf[i];
                                    if (char === '(') depth++;
                                    else if (char === ')') depth--;
                                    
                                    if (depth === 0 && afterKeysOf.substring(i, i + sep.length) === sep) {
                                        splitIndex = i;
                                        searchPhrase = sep;
                                        break;
                                    }
                                }
                                if (splitIndex !== -1) break;
                            }
                            
                            if (splitIndex !== -1 && searchPhrase) {
                                const keyTypeStr = afterKeysOf.substring(0, splitIndex).trim();
                                const valueTypeStr = afterKeysOf.substring(splitIndex + searchPhrase.length).trim();
                                
                                return {
                                    type: 'dict',
                                    keyType: this.#parseTypeString(this.#stripParentheses(keyTypeStr)),
                                    valueType: this.#parseTypeString(this.#stripParentheses(valueTypeStr))
                                };
                            }
                        }
                    } else if (rest.startsWith('of ')) {
                        // "dict of X" (str keys) or "dict of X to Y"
                        const afterOf = rest.substring(3).trim();
                        
                        // Look for " to " separator
                        let depth = 0;
                        let splitIndex = -1;
                        const searchPhrase = ' to ';
                        
                        for (let i = 0; i < afterOf.length; i++) {
                            const char = afterOf[i];
                            if (char === '(') depth++;
                            else if (char === ')') depth--;
                            
                            if (depth === 0 && afterOf.substring(i, i + searchPhrase.length) === searchPhrase) {
                                splitIndex = i;
                                break;
                            }
                        }
                        
                        if (splitIndex !== -1) {
                            // "dict of X to Y"
                            const keyTypeStr = afterOf.substring(0, splitIndex).trim();
                            const valueTypeStr = afterOf.substring(splitIndex + searchPhrase.length).trim();
                            
                            return {
                                type: 'dict',
                                keyType: this.#parseTypeString(this.#stripParentheses(keyTypeStr)),
                                valueType: this.#parseTypeString(this.#stripParentheses(valueTypeStr))
                            };
                        } else {
                            // "dict of X" (assumes str keys)
                            return {
                                type: 'dict',
                                keyType: { type: 'str' },
                                valueType: this.#parseTypeString(this.#stripParentheses(afterOf))
                            };
                        }
                    }
                } else if (containerType === 'list' || containerType === 'tuple') {
                    if (rest.startsWith('of ')) {
                        const nested = rest.substring(3).trim();
                        return {
                            type: containerType,
                            mode: 'of',
                            nested: this.#parseTypeString(this.#stripParentheses(nested))
                        };
                    } else if (rest.startsWith('with ')) {
                        const nested = rest.substring(5).trim();
                        const types = this.#parseWithClause(nested);
                        return {
                            type: containerType,
                            mode: 'with',
                            types: types.map(t => this.#parseTypeString(this.#stripParentheses(t)))
                        };
                    }
                }
            }
        }
        
        throw new Error(`Unable to parse type: ${typeStr}`);
    }

    #stripParentheses(str) {
        str = str.trim();
        if (str.startsWith('(') && str.endsWith(')')) {
            // Make sure these are matching outer parentheses
            let depth = 0;
            for (let i = 0; i < str.length; i++) {
                if (str[i] === '(') depth++;
                if (str[i] === ')') depth--;
                if (depth === 0 && i < str.length - 1) {
                    // Found closing paren before end, these aren't outer parens
                    return str;
                }
            }
            return str.substring(1, str.length - 1).trim();
        }
        return str;
    }

    #parseWithClause(str) {
        // Parse "type1, type2, and type3" or "type1 and type2" or mixed
        // Split by commas and/or "and" while respecting parentheses
        const types = [];
        let current = '';
        let depth = 0;
        let i = 0;
        
        while (i < str.length) {
            const char = str[i];
            
            if (char === '(') {
                depth++;
                current += char;
                i++;
            } else if (char === ')') {
                depth--;
                current += char;
                i++;
            } else if (depth === 0) {
                // Check for comma
                if (char === ',') {
                    if (current.trim()) {
                        types.push(current.trim());
                    }
                    current = '';
                    i++;
                    continue;
                }
                
                // Check for " and " (with spaces) - treat as separator
                if (str.substring(i, i + 5) === ' and ') {
                    if (current.trim()) {
                        types.push(current.trim());
                    }
                    current = '';
                    i += 5; // Skip " and "
                    continue;
                }
                
                // Check for "and " at start (after comma/and)
                if (current.trim() === '' && str.substring(i, i + 4) === 'and ') {
                    i += 4; // Skip "and "
                    continue;
                }
                
                current += char;
                i++;
            } else {
                current += char;
                i++;
            }
        }
        
        if (current.trim()) {
            types.push(current.trim());
        }
        
        return types;
    }

    #buildTypeFromParsed(parsed, parentElement) {
        const container = document.createElement('span');
        container.className = 'type-container';
        const id = this.#typeId++;
        container.dataset.id = id;

        const select = document.createElement('select');
        
        // Determine which types to show based on context
        const inSetContext = this.#isInsideSet(parentElement);
        const immutableTypes = [...this.#baseTypes, 'tuple'];
        const typesToShow = inSetContext ? immutableTypes : this.#allTypes;

        typesToShow.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            select.appendChild(option);
        });

        select.value = parsed.type;
        
        // Add change event listener so dropdowns work after parsing
        select.addEventListener('change', (e) => this.#handleTypeChange(e, container, id));
        
        container.appendChild(select);
        parentElement.appendChild(container);

        // Handle container-specific setup
        if (parsed.type === 'set') {
            const connector = document.createElement('span');
            connector.className = 'connector';
            connector.textContent = 'of';
            container.appendChild(connector);
            
            const nestedWrapper = document.createElement('div');
            nestedWrapper.className = 'indented-nested';
            container.appendChild(nestedWrapper);
            
            this.#buildTypeFromParsed(parsed.nested, nestedWrapper);
        } else if (parsed.type === 'dict') {
            const connector = document.createElement('span');
            connector.className = 'connector';
            connector.textContent = 'with';
            container.appendChild(connector);
            
            // Keys section
            const keysWrapper = document.createElement('div');
            keysWrapper.className = 'indented-nested';
            container.appendChild(keysWrapper);
            
            const keysLabel = document.createElement('span');
            keysLabel.className = 'dict-label';
            keysLabel.textContent = 'keys of';
            keysWrapper.appendChild(keysLabel);
            
            this.#buildTypeFromParsed(parsed.keyType, keysWrapper);
            
            // "associated with" on its own line
            const associatedWith = document.createElement('div');
            associatedWith.className = 'dict-connector';
            associatedWith.textContent = 'associated with';
            container.appendChild(associatedWith);
            
            // Values section
            const valuesWrapper = document.createElement('div');
            valuesWrapper.className = 'indented-nested';
            container.appendChild(valuesWrapper);
            
            const valuesLabel = document.createElement('span');
            valuesLabel.className = 'dict-label';
            valuesLabel.textContent = 'values of';
            valuesWrapper.appendChild(valuesLabel);
            
            this.#buildTypeFromParsed(parsed.valueType, valuesWrapper);
        } else if (parsed.type === 'list' || parsed.type === 'tuple') {
            const modeSelect = document.createElement('select');
            modeSelect.className = 'mode-select';

            const ofOption = document.createElement('option');
            ofOption.value = 'of';
            ofOption.textContent = 'of';
            ofOption.title = 'Contains an arbitrary number of elements, all of the same type';
            modeSelect.appendChild(ofOption);

            const withOption = document.createElement('option');
            withOption.value = 'with';
            withOption.textContent = 'with';
            withOption.title = 'Contains a fixed number of elements, each of a possiblydifferent type';
            modeSelect.appendChild(withOption);

            modeSelect.value = parsed.mode;
            
            // Add change event listener so mode selection works after parsing
            modeSelect.addEventListener('change', (e) => this.#updateContainerMode(container, e.target.value));
            
            container.appendChild(modeSelect);

            if (parsed.mode === 'of') {
                const nestedWrapper = document.createElement('div');
                nestedWrapper.className = 'indented-nested';
                container.appendChild(nestedWrapper);
                
                this.#buildTypeFromParsed(parsed.nested, nestedWrapper);
            } else {
                // "with" mode
                parsed.types.forEach((typeObj, index) => {
                    const itemWrapper = document.createElement('div');
                    itemWrapper.className = 'indented-nested';
                    container.appendChild(itemWrapper);
                    
                    const buttonContainer = document.createElement('span');
                    buttonContainer.className = 'nested-leader-container';
                    itemWrapper.appendChild(buttonContainer);

                    const addBtn = document.createElement('button');
                    addBtn.className = 'add-type-btn';
                    addBtn.textContent = '+';
                    addBtn.addEventListener('click', () => {
                        this.#addWithType(container, false);
                        this.#updateWithButtonStates(container);
                    });
                    buttonContainer.appendChild(addBtn);

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-type-btn';
                    removeBtn.textContent = '−';
                    removeBtn.addEventListener('click', () => {
                        itemWrapper.remove();
                        this.#updateWithButtonStates(container);
                        this.#notifyChange();
                    });
                    buttonContainer.appendChild(removeBtn);

                    this.#buildTypeFromParsed(typeObj, itemWrapper);
                });
                
                this.#updateWithButtonStates(container);
            }
        }

        return container;
    }
}

// Export the TypeEditor class
export default TypeEditor;
